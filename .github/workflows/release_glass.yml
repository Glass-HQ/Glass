name: Release Glass

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g., v0.0.1)"
        required: false

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: "1"
  CARGO_INCREMENTAL: "0"

jobs:
  build-macos:
    name: Build macOS (${{ matrix.target }})
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        include:
          - target: aarch64-apple-darwin
            runner: macos-15
            arch: aarch64
            cef_platform: macosarm64
          # Intel build disabled for now - uncomment to re-enable
          # - target: x86_64-apple-darwin
          #   runner: macos-14
          #   arch: x86_64
          #   cef_platform: macosx64

    env:
      MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
      MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
      APPLE_NOTARIZATION_KEY: ${{ secrets.APPLE_NOTARIZATION_KEY }}
      APPLE_NOTARIZATION_KEY_ID: ${{ secrets.APPLE_NOTARIZATION_KEY_ID }}
      APPLE_NOTARIZATION_ISSUER_ID: ${{ secrets.APPLE_NOTARIZATION_ISSUER_ID }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          clean: false

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      # Cache Rust compilation artifacts
      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          # Use a unique key prefix to avoid conflicts
          prefix-key: "v1-rust"
          # Cache the target directory and cargo registry
          shared-key: ${{ matrix.target }}
          # Save cache even if the build fails
          save-if: "true"
          # Cache cargo home directories
          cache-directories: |
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/

      # Cache cargo-bundle separately to avoid rebuilding it every time
      - name: Cache cargo-bundle
        id: cache-cargo-bundle
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/cargo-bundle
            ~/.cargo/.crates.toml
            ~/.cargo/.crates2.json
          key: cargo-bundle-${{ runner.os }}-${{ runner.arch }}-v2

      - name: Install cargo-bundle
        if: steps.cache-cargo-bundle.outputs.cache-hit != 'true'
        run: cargo install cargo-bundle --git https://github.com/zed-industries/cargo-bundle.git --branch zed-deploy

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      # Cache Homebrew packages
      - name: Cache Homebrew
        uses: actions/cache@v4
        with:
          path: |
            ~/Library/Caches/Homebrew
            /opt/homebrew/Cellar/cmake
          key: homebrew-${{ runner.os }}-${{ runner.arch }}-cmake-v1

      - name: Install cmake
        run: brew install cmake || true

      - name: Generate licenses
        run: script/generate-licenses

      # Cache CEF download to avoid re-downloading on each build
      - name: Cache CEF framework
        id: cache-cef
        uses: actions/cache@v4
        with:
          path: ~/.local/share/cef
          key: cef-${{ matrix.cef_platform }}-v144

      - name: Download and extract CEF
        run: |
          CEF_PATH="$HOME/.local/share/cef"
          mkdir -p "$CEF_PATH"

          # Set CEF_PATH for the build
          echo "CEF_PATH=$CEF_PATH" >> $GITHUB_ENV

          # Check if CEF is already cached and valid
          if [ -d "$CEF_PATH/Chromium Embedded Framework.framework" ]; then
            echo "CEF framework found in cache"
          else
            echo "Downloading CEF from Spotify CDN..."

            # CEF version must match what cef-rs expects (check Cargo.lock: cef version 144.3.0+144.0.12)
            CEF_VERSION="144.0.12"
            CEF_CDN="https://cef-builds.spotifycdn.com"

            # Fetch index to get the exact filename with chromium version
            echo "Fetching CEF index..."
            INDEX_JSON=$(curl -sL "$CEF_CDN/index.json")

            # Find the minimal archive for macosarm64 with version 144.0.12
            if [ "${{ matrix.cef_platform }}" = "macosarm64" ]; then
              CEF_FILE=$(echo "$INDEX_JSON" | jq -r '.macosarm64.versions[] | select(.cef_version | startswith("'"$CEF_VERSION"'+")) | .files[] | select(.type == "minimal") | .name' | head -1)
              CEF_SHA1=$(echo "$INDEX_JSON" | jq -r '.macosarm64.versions[] | select(.cef_version | startswith("'"$CEF_VERSION"'+")) | .files[] | select(.type == "minimal") | .sha1' | head -1)
            else
              CEF_FILE=$(echo "$INDEX_JSON" | jq -r '.macosx64.versions[] | select(.cef_version | startswith("'"$CEF_VERSION"'+")) | .files[] | select(.type == "minimal") | .name' | head -1)
              CEF_SHA1=$(echo "$INDEX_JSON" | jq -r '.macosx64.versions[] | select(.cef_version | startswith("'"$CEF_VERSION"'+")) | .files[] | select(.type == "minimal") | .sha1' | head -1)
            fi

            if [ -z "$CEF_FILE" ] || [ "$CEF_FILE" = "null" ]; then
              echo "Error: Could not find CEF version $CEF_VERSION for ${{ matrix.cef_platform }}"
              exit 1
            fi

            echo "Downloading: $CEF_FILE"
            curl -L -o "/tmp/cef.tar.bz2" "$CEF_CDN/$CEF_FILE"

            # Verify SHA1
            DOWNLOADED_SHA1=$(shasum -a 1 /tmp/cef.tar.bz2 | cut -d' ' -f1)
            if [ "$DOWNLOADED_SHA1" != "$CEF_SHA1" ]; then
              echo "Error: SHA1 mismatch. Expected $CEF_SHA1, got $DOWNLOADED_SHA1"
              exit 1
            fi
            echo "SHA1 verified: $CEF_SHA1"

            # Extract archive
            echo "Extracting CEF archive..."
            cd /tmp
            tar -xjf cef.tar.bz2

            # Find extracted directory
            EXTRACTED_DIR=$(ls -d cef_binary_* | head -1)
            echo "Extracted to: $EXTRACTED_DIR"

            # Copy Release folder contents (contains the framework on macOS)
            cp -R "/tmp/$EXTRACTED_DIR/Release/"* "$CEF_PATH/"

            # Copy other needed files
            cp "/tmp/$EXTRACTED_DIR/CMakeLists.txt" "$CEF_PATH/" || true
            cp -R "/tmp/$EXTRACTED_DIR/cmake" "$CEF_PATH/" || true
            cp -R "/tmp/$EXTRACTED_DIR/include" "$CEF_PATH/" || true
            cp -R "/tmp/$EXTRACTED_DIR/libcef_dll" "$CEF_PATH/" || true

            # Create archive.json for version tracking
            echo '{"type":"minimal","name":"'"$CEF_FILE"'","sha1":"'"$CEF_SHA1"'"}' > "$CEF_PATH/archive.json"

            # Cleanup
            rm -rf /tmp/cef.tar.bz2 "/tmp/$EXTRACTED_DIR"
          fi

          # Verify CEF was downloaded
          if [ ! -d "$CEF_PATH/Chromium Embedded Framework.framework" ]; then
            echo "Error: CEF framework not found after download"
            ls -la "$CEF_PATH"
            exit 1
          fi

          echo "CEF framework ready at: $CEF_PATH"
          ls -la "$CEF_PATH"

      - name: Build Glass
        run: |
          export ZED_BUNDLE=true
          export CXXFLAGS="-stdlib=libc++"
          cargo build --release --package zed --package cli --target ${{ matrix.target }}
          cargo build --release --package remote_server --target ${{ matrix.target }}

      - name: Build glass_helper
        run: |
          export CXXFLAGS="-stdlib=libc++"
          cargo build --release --package browser --bin glass_helper --target ${{ matrix.target }}

      - name: Generate debug symbols (for crash reports)
        run: |
          SYMBOLS_DIR="target/${{ matrix.target }}/release/symbols"
          SYMBOLS_ZIP="target/${{ matrix.target }}/release/Glass-${{ matrix.arch }}-symbols.zip"
          rm -rf "$SYMBOLS_DIR"
          mkdir -p "$SYMBOLS_DIR"

          # Match Zed's approach: produce flat .dwarf files suitable for symbolication tooling.
          dsymutil --flat -o "$SYMBOLS_DIR/zed.dwarf" "target/${{ matrix.target }}/release/zed"
          dsymutil --flat -o "$SYMBOLS_DIR/cli.dwarf" "target/${{ matrix.target }}/release/cli"
          dsymutil --flat -o "$SYMBOLS_DIR/remote_server.dwarf" "target/${{ matrix.target }}/release/remote_server"
          dsymutil --flat -o "$SYMBOLS_DIR/glass_helper.dwarf" "target/${{ matrix.target }}/release/glass_helper"

          ditto -c -k --sequesterRsrc --keepParent "$SYMBOLS_DIR" "$SYMBOLS_ZIP"

      - name: Create app bundle
        run: |
          export ZED_BUNDLE=true
          cd crates/zed

          # Backup and modify Cargo.toml for bundling
          cp Cargo.toml Cargo.toml.backup
          channel=$(cat RELEASE_CHANNEL)
          sed -i.backup "s/package.metadata.bundle-${channel}/package.metadata.bundle/" Cargo.toml

          # Create the bundle
          cargo bundle --release --target ${{ matrix.target }} --select-workspace-root

          # Restore original Cargo.toml
          mv Cargo.toml.backup Cargo.toml

      - name: Download git binary
        run: |
          mkdir -p /tmp/git-download
          cd /tmp/git-download
          if [ "${{ matrix.arch }}" = "aarch64" ]; then
            curl -L "https://github.com/desktop/dugite-native/releases/download/v2.43.3/dugite-native-v2.43.3-fa29823-macOS-arm64.tar.gz" | tar -xz bin/git
          else
            curl -L "https://github.com/desktop/dugite-native/releases/download/v2.43.3/dugite-native-v2.43.3-fa29823-macOS-x64.tar.gz" | tar -xz bin/git
          fi

      - name: Prepare app bundle with CEF
        run: |
          APP_PATH=$(find target/${{ matrix.target }}/release -name "*.app" -type d | head -1)
          echo "APP_PATH=$APP_PATH" >> $GITHUB_ENV

          # Copy binaries
          cp target/${{ matrix.target }}/release/zed "$APP_PATH/Contents/MacOS/zed"
          cp target/${{ matrix.target }}/release/cli "$APP_PATH/Contents/MacOS/cli"
          cp /tmp/git-download/bin/git "$APP_PATH/Contents/MacOS/git"

          # Create Frameworks directory
          mkdir -p "$APP_PATH/Contents/Frameworks"

          # Copy CEF framework
          echo "Copying CEF framework..."
          cp -R "$CEF_PATH/Chromium Embedded Framework.framework" "$APP_PATH/Contents/Frameworks/"

          # Create CEF helper app bundles
          APP_NAME="Glass"
          HELPER_PATH="target/${{ matrix.target }}/release/glass_helper"
          HELPERS=("Helper" "Helper (GPU)" "Helper (Renderer)" "Helper (Plugin)" "Helper (Alerts)")

          echo "Creating CEF helper app bundles..."
          for helper_suffix in "${HELPERS[@]}"; do
            HELPER_APP_NAME="${APP_NAME} ${helper_suffix}"
            HELPER_APP_PATH="$APP_PATH/Contents/Frameworks/${HELPER_APP_NAME}.app"

            echo "  Creating: ${HELPER_APP_NAME}.app"
            mkdir -p "$HELPER_APP_PATH/Contents/MacOS"

            # Copy helper executable
            cp "$HELPER_PATH" "$HELPER_APP_PATH/Contents/MacOS/${HELPER_APP_NAME}"

            # Generate unique bundle identifier suffix for each helper type
            # Helper -> .helper, Helper (GPU) -> .helper.GPU, etc.
            if [ "$helper_suffix" = "Helper" ]; then
              BUNDLE_ID_SUFFIX=""
            else
              # Extract the type from "Helper (GPU)" -> "GPU"
              BUNDLE_ID_SUFFIX=".$(echo "$helper_suffix" | sed 's/Helper (\(.*\))/\1/')"
            fi

            # Create helper Info.plist with unique bundle identifier
            cat > "$HELPER_APP_PATH/Contents/Info.plist" << HELPER_PLIST
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleName</key>
              <string>${HELPER_APP_NAME}</string>
              <key>CFBundleDisplayName</key>
              <string>${HELPER_APP_NAME}</string>
              <key>CFBundleIdentifier</key>
              <string>dev.glass.Glass.helper${BUNDLE_ID_SUFFIX}</string>
              <key>CFBundleVersion</key>
              <string>0.1.0</string>
              <key>CFBundleShortVersionString</key>
              <string>0.1.0</string>
              <key>CFBundlePackageType</key>
              <string>APPL</string>
              <key>CFBundleExecutable</key>
              <string>${HELPER_APP_NAME}</string>
              <key>CFBundleInfoDictionaryVersion</key>
              <string>6.0</string>
              <key>LSMinimumSystemVersion</key>
              <string>11.0</string>
              <key>LSUIElement</key>
              <string>1</string>
              <key>LSEnvironment</key>
              <dict>
                  <key>MallocNanoZone</key>
                  <string>0</string>
              </dict>
              <key>NSSupportsAutomaticGraphicsSwitching</key>
              <true/>
          </dict>
          </plist>
          HELPER_PLIST

            echo "    Bundle ID: dev.glass.Glass.helper${BUNDLE_ID_SUFFIX}"

            # Create PkgInfo for helper
            echo "APPL????" > "$HELPER_APP_PATH/Contents/PkgInfo"
          done

          echo "CEF bundling complete"
          echo "Frameworks directory contents:"
          ls -la "$APP_PATH/Contents/Frameworks/"

      - name: Setup code signing
        if: env.MACOS_CERTIFICATE != ''
        run: |
          # Create temporary keychain
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings build.keychain

          # Import certificate
          echo "$MACOS_CERTIFICATE" | base64 --decode > /tmp/certificate.p12
          security import /tmp/certificate.p12 -k build.keychain -P "$MACOS_CERTIFICATE_PASSWORD" -T /usr/bin/codesign
          rm /tmp/certificate.p12

          # Allow codesign to access keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" build.keychain

          # Get the signing identity
          IDENTITY=$(security find-identity -v -p codesigning build.keychain | grep "Developer ID Application" | head -1 | awk -F'"' '{print $2}')
          echo "SIGNING_IDENTITY=$IDENTITY" >> $GITHUB_ENV
          echo "CAN_SIGN=true" >> $GITHUB_ENV

      - name: Code sign app bundle
        run: |
          ENTITLEMENTS="crates/zed/resources/zed.entitlements"
          APP_NAME="Glass"
          HELPERS=("Helper" "Helper (GPU)" "Helper (Renderer)" "Helper (Plugin)" "Helper (Alerts)")
          CEF_FRAMEWORK="$APP_PATH/Contents/Frameworks/Chromium Embedded Framework.framework"

          # Sign a single file (based on cef-sample codesign.py)
          # Uses --options runtime only for executable files
          sign_file() {
            local file="$1"
            local identity="$2"
            local entitlements="$3"

            local cmd=("/usr/bin/codesign" "-f" "-s" "$identity")

            # Add hardened runtime only for executables
            if [ -x "$file" ]; then
              cmd+=("--options" "runtime")
            fi

            # Add entitlements if provided
            if [ -n "$entitlements" ]; then
              cmd+=("--entitlements" "$entitlements")
            fi

            cmd+=("$file")

            echo "  Signing: $file"
            "${cmd[@]}"
          }

          # Sign files in a directory (inside-out order)
          # Based on cef-sample codesign.py VALID_SIGNING_PATHS
          sign_contents() {
            local contents_path="$1"
            local identity="$2"
            local entitlements="$3"

            # Order matters: innermost first (Frameworks, Libraries before MacOS)
            local signing_paths=("Frameworks" "Libraries" "PlugIns" "Helpers" "MacOS")

            for subdir in "${signing_paths[@]}"; do
              local dir_path="$contents_path/$subdir"
              if [ -d "$dir_path" ]; then
                # Find and sign bundles first
                find "$dir_path" -maxdepth 1 -type d -name "*.app" -o -name "*.framework" 2>/dev/null | while read -r bundle; do
                  sign_bundle "$bundle" "$identity" "$entitlements"
                done

                # Then sign dylibs and executables
                find "$dir_path" -maxdepth 1 -type f \( -name "*.dylib" -o -perm +111 \) 2>/dev/null | while read -r file; do
                  sign_file "$file" "$identity" "$entitlements"
                done
              fi
            done
          }

          # Sign a framework bundle (handles Versions directory)
          sign_framework() {
            local framework_path="$1"
            local identity="$2"
            local entitlements="$3"

            echo "Signing framework: $framework_path"

            local versions_path="$framework_path/Versions"
            if [ -d "$versions_path" ]; then
              # Sign each version
              for version_dir in "$versions_path"/*/; do
                if [ -d "$version_dir" ] && [ ! -L "$version_dir" ]; then
                  # Sign Libraries inside the version
                  if [ -d "$version_dir/Libraries" ]; then
                    find "$version_dir/Libraries" -type f \( -name "*.dylib" -o -perm +111 \) 2>/dev/null | while read -r lib; do
                      sign_file "$lib" "$identity" ""
                    done
                  fi

                  # Sign the main framework binary
                  local framework_name=$(basename "$framework_path" .framework)
                  local framework_binary="$version_dir/$framework_name"
                  if [ -f "$framework_binary" ]; then
                    sign_file "$framework_binary" "$identity" ""
                  fi
                fi
              done
            else
              # Flat framework structure
              local framework_name=$(basename "$framework_path" .framework)
              local framework_binary="$framework_path/$framework_name"

              # Sign Libraries
              if [ -d "$framework_path/Libraries" ]; then
                find "$framework_path/Libraries" -type f \( -name "*.dylib" -o -perm +111 \) 2>/dev/null | while read -r lib; do
                  sign_file "$lib" "$identity" ""
                done
              fi

              # Sign main binary
              if [ -f "$framework_binary" ]; then
                sign_file "$framework_binary" "$identity" ""
              fi
            fi

            # Sign the framework bundle itself
            sign_file "$framework_path" "$identity" ""
          }

          # Sign an app bundle
          sign_bundle() {
            local bundle_path="$1"
            local identity="$2"
            local entitlements="$3"

            echo "Signing bundle: $bundle_path"

            # Check if it's a framework
            if [[ "$bundle_path" == *.framework ]]; then
              sign_framework "$bundle_path" "$identity" "$entitlements"
              return
            fi

            local contents_path="$bundle_path/Contents"
            if [ -d "$contents_path" ]; then
              sign_contents "$contents_path" "$identity" "$entitlements"
            fi

            # Sign the bundle itself
            local cmd=("/usr/bin/codesign" "-f" "-s" "$identity" "--options" "runtime")
            if [ -n "$entitlements" ]; then
              cmd+=("--entitlements" "$entitlements")
            fi
            cmd+=("$bundle_path")
            "${cmd[@]}"
          }

          if [ "$CAN_SIGN" = "true" ]; then
            echo "Signing with Developer ID: $SIGNING_IDENTITY"
            echo "Using entitlements: $ENTITLEMENTS"

            # 1. Sign CEF framework first (innermost)
            sign_framework "$CEF_FRAMEWORK" "$SIGNING_IDENTITY" ""

            # 2. Sign CEF helper apps
            for helper_suffix in "${HELPERS[@]}"; do
              HELPER_APP_NAME="${APP_NAME} ${helper_suffix}"
              HELPER_APP_PATH="$APP_PATH/Contents/Frameworks/${HELPER_APP_NAME}.app"
              sign_bundle "$HELPER_APP_PATH" "$SIGNING_IDENTITY" "$ENTITLEMENTS"
            done

            # 3. Sign main app binaries
            echo "Signing main app binaries..."
            sign_file "$APP_PATH/Contents/MacOS/cli" "$SIGNING_IDENTITY" "$ENTITLEMENTS"
            sign_file "$APP_PATH/Contents/MacOS/git" "$SIGNING_IDENTITY" "$ENTITLEMENTS"
            sign_file "$APP_PATH/Contents/MacOS/zed" "$SIGNING_IDENTITY" "$ENTITLEMENTS"

            # 4. Sign the main app bundle
            echo "Signing main app bundle..."
            /usr/bin/codesign -f -s "$SIGNING_IDENTITY" --options runtime \
              --entitlements "$ENTITLEMENTS" "$APP_PATH"

            # Verify signatures
            echo "Verifying signatures..."
            /usr/bin/codesign --verify --deep --strict "$APP_PATH" -v

          else
            echo "No signing certificate available, using ad-hoc signing"

            # Ad-hoc sign CEF framework
            find "$CEF_FRAMEWORK" -type f \( -name "*.dylib" -o -perm +111 \) -exec codesign -f -s - {} \;
            codesign -f -s - "$CEF_FRAMEWORK"

            # Sign CEF helpers
            for helper_suffix in "${HELPERS[@]}"; do
              HELPER_APP_NAME="${APP_NAME} ${helper_suffix}"
              HELPER_APP_PATH="$APP_PATH/Contents/Frameworks/${HELPER_APP_NAME}.app"
              codesign -f -s - "$HELPER_APP_PATH/Contents/MacOS/${HELPER_APP_NAME}"
              codesign -f -s - "$HELPER_APP_PATH"
            done

            # Sign main binaries and app
            codesign -f -s - "$APP_PATH/Contents/MacOS/cli"
            codesign -f -s - "$APP_PATH/Contents/MacOS/git"
            codesign -f -s - "$APP_PATH/Contents/MacOS/zed"
            codesign -f -s - "$APP_PATH"
          fi

      - name: Create DMG
        run: |
          DMG_DIR="target/${{ matrix.target }}/release/dmg"
          DMG_PATH="target/${{ matrix.target }}/release/Glass-${{ matrix.arch }}.dmg"
          mkdir -p "$DMG_DIR"
          cp -R "$APP_PATH" "$DMG_DIR/"
          ln -s /Applications "$DMG_DIR/Applications"

          hdiutil create -volname "Glass" \
            -srcfolder "$DMG_DIR" \
            -ov -format UDZO \
            "$DMG_PATH"

          echo "DMG_PATH=$DMG_PATH" >> $GITHUB_ENV

      - name: Sign and notarize DMG
        if: env.CAN_SIGN == 'true' && env.APPLE_NOTARIZATION_KEY != ''
        timeout-minutes: 30
        run: |
          # Sign the DMG
          /usr/bin/codesign --deep --force --timestamp --options runtime --sign "$SIGNING_IDENTITY" "$DMG_PATH" -v

          # Decode the base64-encoded .p8 key
          echo "$APPLE_NOTARIZATION_KEY" | base64 --decode > /tmp/notarization_key.p8
          chmod 600 /tmp/notarization_key.p8

          # Notarize and capture output to get submission ID
          NOTARIZE_OUTPUT=$(xcrun notarytool submit --wait \
            --key /tmp/notarization_key.p8 \
            --key-id "$APPLE_NOTARIZATION_KEY_ID" \
            --issuer "$APPLE_NOTARIZATION_ISSUER_ID" \
            "$DMG_PATH" 2>&1) || {
            echo "$NOTARIZE_OUTPUT"

            # Extract submission ID and fetch detailed log
            SUBMISSION_ID=$(echo "$NOTARIZE_OUTPUT" | grep -o 'id: [a-f0-9-]*' | head -1 | cut -d' ' -f2)
            if [ -n "$SUBMISSION_ID" ]; then
              echo ""
              echo "=== Fetching notarization log for submission $SUBMISSION_ID ==="
              xcrun notarytool log "$SUBMISSION_ID" \
                --key /tmp/notarization_key.p8 \
                --key-id "$APPLE_NOTARIZATION_KEY_ID" \
                --issuer "$APPLE_NOTARIZATION_ISSUER_ID" || true
            fi

            rm -f /tmp/notarization_key.p8
            exit 1
          }

          echo "$NOTARIZE_OUTPUT"
          rm /tmp/notarization_key.p8

          # Staple the notarization ticket
          xcrun stapler staple "$DMG_PATH"

      - name: Verify code signing
        if: env.CAN_SIGN == 'true'
        run: |
          echo "Verifying app signature..."
          /usr/bin/codesign --verify --strict --deep --verbose=4 "$APP_PATH"

          echo "Verifying DMG signature..."
          /usr/bin/codesign --verify --strict --verbose=4 "$DMG_PATH"

          echo "Assessing app with Gatekeeper..."
          spctl --assess --type execute --verbose=4 "$APP_PATH"

      - name: Verify notarization
        if: env.CAN_SIGN == 'true' && env.APPLE_NOTARIZATION_KEY != ''
        run: |
          echo "Validating stapled notarization ticket..."
          xcrun stapler validate "$DMG_PATH"

      - name: Cleanup keychain
        if: always()
        run: |
          security default-keychain -s login.keychain || true
          security delete-keychain build.keychain || true

      - name: Upload DMG artifact
        uses: actions/upload-artifact@v4
        with:
          name: Glass-${{ matrix.arch }}.dmg
          path: target/${{ matrix.target }}/release/Glass-${{ matrix.arch }}.dmg
          if-no-files-found: error

      - name: Upload symbols artifact
        uses: actions/upload-artifact@v4
        with:
          name: Glass-${{ matrix.arch }}-symbols.zip
          path: target/${{ matrix.target }}/release/Glass-${{ matrix.arch }}-symbols.zip
          if-no-files-found: error

  create-release:
    name: Create GitHub Release
    needs: [build-macos]
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: List artifacts
        run: ls -lR artifacts

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          name: Glass ${{ github.ref_name }}
          draft: false
          prerelease: false
          files: |
            artifacts/Glass-aarch64.dmg/Glass-aarch64.dmg
            artifacts/Glass-aarch64-symbols.zip/Glass-aarch64-symbols.zip
            # Intel build disabled - uncomment when re-enabled:
            # artifacts/Glass-x86_64.dmg/Glass-x86_64.dmg
          body: |
            ## Glass ${{ github.ref_name }}

            ### Installation

            1. Download the DMG: `Glass-aarch64.dmg` (Apple Silicon Macs - M1/M2/M3/M4)
            2. Open the DMG and drag Glass to Applications
            3. Launch Glass from Applications

            > **Note:** Only Apple Silicon builds are available at this time. Intel Mac support coming later.
